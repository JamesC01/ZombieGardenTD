09/02/2024

I've become much more open minded when listening to guys like Casey Muratori, and I feel like I've learned a lot.
The goal of this project is to apply the idea of writing code as simply as possible, without too much planning,
and no premature abstraction. Another goal is to also just enjoy programming. Enjoy lower level C programming.
Also partly to see if I even do enjoy it. I spent around 1 hour today workong on this project.


10/02/2024

I've spent 3 hours (2 hours today) on this project so far (including doing the sprites) and I'm really enjoying it.
It feels very natural, and I'm not doing too much planning, it's just organically growing. I think planning should
be a balance. Planning can be very difficult when there are lots of different things interacting. It's too much to
keep in your head, or even written down, sometimes, so this gung-ho style of programming feels very nice. I like the idea of
just loosely planning something, or thinking about a simple implementation of it, and then just doing it. It feels
right.

I'm definitely doing a bit of planning, but it's mostly in my head. I'm just thinking of the simplest ways of doing
things, and then thinking a *little* bit further about how the thing I'm implementing might interact with the other
things in my game. The mentality I'm going for is one where I plan simple things (either in my head, or write them
down), and just implement them. If they need changing later, then so be it. The truth is, even if I spent an hour
planning, there's still a good chance I'd overlook something, so I think it's good to just get it out of the way
and implement it in a working, but not very abstracted way, and then if I find myself repeating similar code, then
I can think about how to abstract/compress it.

The planning I've been thinking about is stuff like "how will the projectiles hit the zombies?" and "how will the
zombies be able to eat the plants?" When thinking about these types of problems, I find my brains tries to think
of ways of implementing it, which is great. I think the problem arises from when spend too much time planning, and
try too hard to plan ahead for future features, when you aren't even sure how to implement them. Actually planning
the implementation isn't too bad, but it's when you abstract it before you even need to. Regardless, I still really
like this feeling of not obsessively planning. It feels fun. It's similar to what Casey Muratori describes as
"exploration-based architecture", where you aren't 100% how to solve the problem, so you're just exploring around,
rather than planning heavily, since you aren't sure what you're in for.


11/02/2024

Today I spent 2 hours and 3 minutes getting suns working in the game, making a shovel sprite, and making the seedpackets
and shovel have a shadow behind them when they're being dragged. Implementing stuff from scratch like this seems to take
quite a while, but I'm enjoying myself, and I'd imagine it gets faster with time. I suppose you get the added benefit of
knowing how pretty much all of your game logic works, whereas in an engine, the engine would handle a lot of it for you,
which can get in the way of things, sometimes. I think both are good. When I want to make something more ambitious, with
lots of features like animations, physics, UI, etc., then I'd probably go with Godot. But if I want to enjoy some programming,
and also just have some fun, then doing stuff from scratch is great, and very worthwhile, because it just gives you more
in-depth problems-solving experience.

So after 5 hours working on this game, I've gotten a peashooter plant and a garden grid where you can place them. I've got
suns that act as a currancy. I've got a shovel which allows you to dig up plants, and that's about it. Of course, a lot actually
went into it. I had to do 99% of the logic myself. There's a couple utily functions for doing simple collision checks that are
built into raylib, but I could do those trivially.

Maybe at some point the novetly of writing this (mostly) from scratch in C will run out, or maybe this will be start of
many more from-scratch projects. I think the areas that I will get bored of are repetetive ones, where I find myself
writing the same code multiple times for different projects. If I get to that point, instead of getting bored, maybe just
copy-paste, or try to create a simple library that I can bring into future projects.

Then again, I have written multiple projects without an engine, and I've enjoyed pretty much all of them. Although it isn't
fun to write the same code over and over without improvements, so like I said, make a library out of it. Doesn't have to
be amazingly designed.

I think the projects that favour being made from scratch are tile/grid based things. A voxel engine, a roguelike, a game like
terraria. These are all things I've had a go at making, and they're all fairly nice to implement when doing it from scratch.
Engines kind of complicate games like this, where you might need procedural generation, and need a lot of control over specific
things.

When I tried to make a zelda-like RPG, I had quite a hard time. But with that project, it was very object-oriented and I think
I overcomplicated things. If I redid that project, or made a slightly similar one, but with less complex features, closer to Zelda
1, maybe it wouldn't be too hard, to at least get most of the mechanics working. Could be a good challenge, but I'm not sure if
I want to spent like a month on something just for a challenge. The C++ roguelike I made, and the C# monogame RPG I made both took
about a month, and they were both very minimal and kind of boring. If I'm going to put time into a complex project from-scratch like
that, I'd want to do it differently, and kind of have more fun with it, and create something actually interesting. You only have so
much time in your life, so I'd rather spend it making something cool, rather than spending a month on something that I did purely
as a coding exercise. You can enjoy coding, and get better at it by working on creative projects. Ironically, you probably would actually
improve more at something you enjoy making, because you're more engaged in it. So while it seems like a good idea to do something as
a "coding exercise", it's probably just better to have fun and explore (most of the time, at least.)

I think from-scratch development *can* be fast, once you're good at it, but I'll have to wait and see. Regardless of if it takes a lot
more time or not, it's still enjoyable, and valuable.

The next time I work on this project, I would like to get some sound effects working. That would really bring it to life.
I think the next plant I'll work on is the sunflower. Once that's implemented, the zombies should come next!


12/02/2024

Took 1 hour and 20 minutes this session! I did a decent bit. I implemented cooldowns for the seed packets, I refactored a decent bit of
stuff, pulled stuff out into seperate functions when the function became hard to read, replaced a bunch of hardcoded values with constants,
I implemented a sunflower (not done the sprite yet), and I fixed a bug where the mouse being clicked would highlight the grid even when
you weren't dragging anything. There might be more things, but that's the bulk of it. It's coming along quite nicely. Implenting the sunflowers
didn't take very long, at most about 30 minutes, but that includes a bit of refactoring. I used a lookup table for finding the plant cooldowns,
because putting a cooldownMax variable on every plant didn't feel right, for some reason. Having to keep those values consistent when spawning
the plant just seems like an extra step, so I put all of the cooldown values in an array, and used the PlantType enums to index into it. I got
this idea from seeing some code Casey Muratori wrote, where he used a lookup table for something. I'm not sure if it's the right thing to do
in this case, but it felt right.


13/02/2024

(Note: I spent around 30 minutes on the sound effects, consider subtracting that from the time if you want, but right now, it's part of the
2 hours 57 minutes.)

Spent 2 hour 57 minutes this session. I made the sunflower sprite, made lots of small tweaks, and also implemented zombies (currently using a
ripped plants vs zombies sprite). They spawn from the right side of the screen, and can be damaged from projectiles, and when they run into
a plant, they stop moving and start damaging it. It all works so far! Still no sound effects yet, but I had a good time implementing zombies.

I also added sound effects that I recorded myself with my SM57, but I haven't tested them yet, since WSL doesn't have audio. I also made some
value tweaks to the cooldowns, sun value, and certain rates to make it closer to plants vs zombies.

Next time I think I wall add the wallnut, which would be incredibly easy to implement, but I will have to figure out a nice way to represent
different health values for plants. I could technically just increase the value, but I chose floats because I wanted health to be from 0 to,
1, so I might have to rework some stuff. Also, doing the sprite for the zombie would be nice, since I want to make my own assets for this game.

I also fixed a bug where you could plant a plant over another plant and it would replace it.


15/02/2024

(Note: I spent 37 minutes working on a track for the game, but I haven't added it to the main time, since I'm not sure if I'll use it.)

Spent 3 whole hours today! I pushed the project to a github repo (but I don't think I timed that), I made peashooters only shoot a zombie when one
is in their row. I added wallnuts, along with a sprite, and tweaked the zombie speed and damage. I implemented the cherry bomb, particles for the
explosion and when the peashooters shoot a pea and hit zombies. And I added a simple zombie spawn wave at 2 minutes in, and made tweaks to the
spawnrates to make it more enjoyable to play. Quite a bit! The code is started to get a bit messy at almost 700 lines, now, so spending some time
to look over the code and consider splitting it into multiple files might be a good idea, and compressing down some of the repetetive constructs I
have in there.

Next time, I'd like to add some more sound effects, maybe do some music for it, and like I said, some refactoring. I was looking for an explosion
sound on freesound, but couldn't find a good one, so I might make all sound effects in the game with mouth sounds or foley. I can layer sounds, and
pitch them and add effects to hide the fact that they're just my mouth.


16/02/2024

(Note: I spent around 10 minutes doing more reorganizing, but it wasn't timed.) I spent some time (probably 20 minutes or so working a bit more
on the theme song, but didn't time it.) I also spent an extra 24 minutes (which I did time, and added to the main text below.)

Spent 1 hour 40 minutes (+24 minutes music prod) today. I made the peashooters only shoot if the zombie is on screen, I made plant positioning more consistent which helped
with adding shadows, which I also did. Finally I restructured the project into multiple files. I'm not sure if this was the right move, but game.c
was getting quite big at 700 lines, and I have to keep jumping from the bottom to the top constantly. The make working with multiple files more
efficient and enjoyable, I'll probably have to learn about using tabs in vim, so I can switch between my working files fairly quickly. I've just tried
to split up the files logically, so if some of the code inside of game.c gets quite big, I pulled it off into a seperate file. For the smaller things,
they can probably stay in game.c. It's good to look at other people's code and see how they're seperated the files.


17/02/2024

(Note: I spent 51 minutes working on the theme song, I haven't added this to the time below, though.)

I spent around 1 hour today (exluding the music). Not a very productive day, but I reorganized the project a bit more, gaves zombies shadows and improved
their positioning a bit (like I did with plants last time), I changed the rate that the zombies groan/growl. With the restructure, it's getting a bit harder
to think about the code, since it's all in seperate files, but when I know exactly what I want to change, it's nicer to be able to go to that specific file.
For example, if I know that I want to do some debugging/tweaks to the zombies, I can just easily go to their file, and tweak the values. Previously, their
variables and code were scattered all over the game.c file. I haven't made a seperate file for some things, or even seperate functions, because there isn't
much code.


18/02/2024

(Note: I spent around 29 minutes working on the theme song, I didn't add the time below.)

I spent 1 hour 30 minutes today. I didn't get that much done considering the time. The project is getting to that stage where it's almost done, or at least
most of the fun logic stuff is done. Now it's just onto small tweaks to things, sound effects, and cleaning up the code. Today was the first time I felt a
bit annoying while working on this project, which is surprising, considering how long I've spent on it. I was trying to implement a random float function,
and I just couldn't do it. Luckily I stopped working on it before I got too annoyed. Going into those negative mindsets is really destructive, and takes
away so much enjoyment, so I need to catch them before they ruin programming for the rest of the day.

What I actually got done, was I made sure the same zombie groan sound wouldn't play twice in a row. After I increased the groan rate, it started getting
really annoying hearing the exact same sound getting playing multiple times in a row, so I fixed it. I also added some quick debug directives for
quickly debugging the zombies. I didn't want to keep having to go back and change the zombie spawn cooldown to 0 and the spawn position manually, so I
made a single #define called ZOMBIE_DEBUG, which I can just set to true or false. You can apparently assign preprocessor directives when compiling with
-D name(=definition), so that could be even more useful.

I also did a decent bit of code cleanup. I finally automated the positioning of the seedpackets, replaced some ugly array accesses with a pointer. That's
mostly it. Not massively productive, but I wasted quite a bit of time on the random function which I couldn't get working.


19/02/2024

I spent 2 hours 47 minutes today, and got a decent bit done! I added a music toggle (since I wanted to listen to music while working on the game.) I added
an game init function to allow me to restart the game without actually exiting to the program. I implemented simple infinite waves. I changed the grid cell
size, which surprisingly didn't really cause any issues (apart from one small tweak I had to make to the peashooter.) The grid now takes up the majority
of the screen, like it does in the real plants vs zombies. I implemented a game over and start screen, and made it so game over happens when the zombie goes
off the left edge of the screen. I encountered another funny bug where the zombie was accessing index -1 while eating the plant, and it was actually accessing
the y position of one of the seed packets, so the cherry bomb seed packet started flying off screen when the zombie got to the edge! I also implemented a unique
random function, where you can pass it a value to exlude, to get a unique value each time, which helps with spreading the zombies out along the rows. I think it
might be a good idea to only use it during waves, though, since it's kind of fun when two zombies are in the same row occasionally. And when they're spawning
slowly, it's fairly rare, so I might change it. I also added a frame limit toggle, and got rid of the old method of speeding up in increments. Now I can just
toggle between targetting 60 fps and max fps. Finally I removed the default exit key (ESCAPE), because I wanted to use it for returning to the start screen.

Overall, I got quite a bit done, and had a great fun time. It's so surprinsing how enjoyable the 19 hours and 17 minutes of working on this project have been.
Going in with the mentality of having fun really helps. And I made sure not to get obsessed with planning for this, and it has been probably one of the most
enjoyable programming projects I've worked on. Yesterday I did get a bit annoyed because I couldn't implement a certain function, so I need to make sure I never
slip into that mentality again, though. But for basically 99% of the project, it has been great fun! It's very enjoyable not having this high pressure mentality
of having to make a "good" game, and to just enjoy the programming side of things. It's got me to do a bit of (albeit pretty bad) pixel art, and I had a great
time making the theme song, which I'll probably continue tweaking.

I've learned that I love the approach to programming where you avoid premature abstraction. Casey Muratori really was right. This project has been fun as hell so
far. And it's not like this is just some honeymoon phase (not completely, at least), because when I wanted to make a game with C++ a year ago, I had a much worse
time dealing with the standard library and struggling with the planning on design of classes and stuff like that. I do think C++ has some good stuff, though, so
I may use it for future projects, for stuff like operator overloading.

This has probably been the most consistent I've ever worked on the project, and the most I've enjoyed working on a project. I really think it is because of the
lack of worrying about doing things the "right way", like planning everything carefully using object oriented techniques and what not. I'm just writing the code
that I know will do the things I want it to, and it's working, and I'm loving it. Of course, I may run into something that I really struggle with, but I will make
sure to avoid that negative mindset. This project really hasn't been challenging, though. It has been a great way to exercise my current skills, and just enjoy
programming in general, but it hasn't pushed me. That's not a bad thing, though. This was meant to be a side project purely for fun, plus a little bit of experience.

I think it's important to work on the things that you find interesting. Of course, sometimes you should push yourself out of your comfort zone, and ideally making
the things that interest you will automatically do that. I think if anything, though, the fact that I haven't struggled is a sign that I'm doing things right, probably.
If I had made this project in Monogame, and had gone with an object-oriented and heavy planning approach, it absolutely would've taken longer, and I probably would've
run into many problems that weren't really logic related, but problems with the structure of the programming, and how objects interact. The way I've done it here has
been straight forward, and it has been fun as hell!

For future projects, I think I will try to make something smaller, and explore individual ideas (conways game of life), little coding challenges to push me a bit.
Pushing myself a bit will be a great exercise in enjoying the process of problem solving and will hopefully teach me to not get angry when I'm stuck. Eventually,
I would like to make something like a simulation game. Nothing big, but something similar to the original simcity, but maybe a bit cut down. That would likely be
challenging, but also enjoyable.

I would like to also get back with Godot, and try some of these ideas, at least a bit, the idea of avoiding premature abstraction, and hopefully reprogram the way I
respond to godot. I've developed such a negative mentality to the engine, when it doesn't do things the way I want, and I want to get over it. Because if I want to
make 3D games, godot is very nice, and plenty of people I respect have managed to make cool stuff with it, so I really just need to learn to stop getting mad when
I get stuck, and learn that programming isn't always "clean". Sometimes the solution is a bit dirty, but what matters is you found a solution. Just make stuff.

Of course, for these C projects, they are much more programming-oriented, since they're done to enjoy coding, rather than to focus on making a game.

I love these programming focused projects. Some inspirations I can think of are: minecraft, dwarf fortress, factorio. You know, those types of games, made by programmers
who probably enjoyed the hell out of programming them. I've still got more planned for this project, and will keep working on it until I get bored of it, or feel that
it's complete.


20/02/2024

I spent 1 hour 30 minutes today, and got barely anything done. Wasn't a bad time, though, it was just kind of difficult to figure things out. The parts I'm working
on have gotten a bit jumbled, and may need some reorganizing. Also, the project has gotten to that point where the basic gameplay is pretty much fully implemented,
so there's less and less visible changes each time I work on it. I don't really plan on adding much extra content, either, apart from some fun visual effects. I can
sense that the end of the project is near.

Anyway, I implemented a simple fps counter at the bottom of the screen, which prompted me to maybe start working on the performance, since a simple 2d game like this
shouldn't only run at 300 fps, I don't think. Maybe it's not too bad, or maybe raylib is the bottleneck. Either way, it would be just for fun, since it isn't necessary.
It runs at a fine 60fps on my terrible laptop.

I improved the way waves work. It will spawn a certain amount of zombies for each wave, and then stop once they're spawned, and then once they're all killed, their speed
will increase slightly, to increase difficulty, and the spawn rate of non-wave zombies will also increase. I also added a simple way to pause the game, but realised that
if I want to pause the game and still see the game in the background, either I'll have to copy the previously renderered frame into a texture and draw that while it's
paused, or I'll have to split up the update and draw code, which probably isn't a bad idea anyway. That's the standard in every other framework. I suppose since the project
started fairly simply, I just didn't do it. All of the raylib examples split rendering and update, so clearly it's a decent idea. Also keeps the logic on its own so I can
focus on it easier when I'm working on it, not having to worry about the rendering code being right next or mixed in with it.

I also fixed when peashooters start shooting at zombies. Previously they were starting to shoot the zombie slightly off screen, which would despawn before hitting the zombie.
I think I fixed it, now.

Overall, not a very productive day, but that's just how it is sometimes. Some features or problems take longer than they seem like they should, and as you start getting further
on with a project, less and less things need to be changed, so you see less and less visual/big features being added. Although in this case, I actually just took longer to solve
the problem for what it was, partly because the code is spread around quite a bit. I've had to jump around quite a bit. Might be time to put some of the variables into a struct
to keep them all together, or just try to simplify stuff in general.


21/02/2024

I spent around 1 hour 30 minutes (plus up to ten minutes of untimed work) today. I had fun! I changed seed packets to be click dragged more like the real PvZ, where you click
to pick it up, then click to plant it, rather than holding left click and dragging. It will make it nicer for a laptop touch pad. I made a function to increment the next "pointer",
for object "pools". I seperated the sun code into a seperate file, and also got rid of globals.c/h, and merged most of it into game.c/h instead. I implemented a cooldown timer,
similar to the one used by plants, but able to be used with simple ints instead, and got rid of the plant specific one. And I finally implemented a working random float function,
and it really wasn't that hard. I just had to break it down and think about it a bit more. I had fun doing it! I'm not 100% sure if it's good, but it at least functions for what
I want to do with it. And when I break it down and walk through the code, it seems to make sense with multiple different values, negative and positive.

Not a very flashy update, but I feel satisfied with the amount I did. I think next time I really need to finally start work on the last couple of sprites, the zombie and cherrybomb.
Once those are done, all of the sound effects, music, and graphics will be by me. I'd also like to update the font used, the current one is pretty crap. I won't be making my own
font, though!

The game is really starting to reach its final point, at least for what I wanted to make. Of course I could expand and start adding levels, new plants, new zombie types, but
that isn't what I set out to do. I wanted to create a simple plants vs zombies clone, and so far I've got it, and have had a lot of fun writing the code. This is literally
the most I've ever enjoyed working on a project. It's just been pure problem solving, with no negative emotions, apart from a single 10-20 minutes earlier on trying to make a random
random, that I implemented today, without any negative feelings.



22/02/2024

I spent 30 minutes drawing sprites today, and 1 hour 29 minutes working on the code. I drew a cherrybomb sprite, and improved the look of the seedpacket sprite. I also started using
2 new fonts for big and small text, which looks much better, although, not very good. I also spent a decent bit of time refactoring code. Reducing the semantic complexity of it. One
of the things I did is something that I learned recently. In an if statement, if the condition is complex, it's good to seperate it out into a seperate bool variable, with a good
name. So instead of having code like:

// Check if pos is within bounds
if (pos.x > 0 && pos.x < WIDTH && pos.y > 0 && pos.y < HEIGHT) {
    // code
}

You should instead do:

bool withinBounds = pos.x > 0 && pos.x < WIDTH && pos.y > 0 && pos.y < HEIGHT;
if (withinBounds) {
    // code
}

As you can see, it's just a bit nicer, and avoids using a comment. I also got rid of a lot of cases where I was repeating a variable name in a for loop, like gardenGrid[i][j]. Instead
I put that in a pointer, like:

Plant* p = gardenGrid[i][j];

Which makes referring to it in many places much shorter.

Overall, didn't do a massive amount today, but I still enjoyed myself.




23/02/2024

(Note: I spent 25 minutes creating the rain loop, and that time isn't added to the time said below.)

Today I spent 2 hours 5 minutes working on the game (exluding the above note). I got a decent bit done. I refactored the object pool globals into its own struct, I implemented some
fun secret things, like confetti particles when you right click and aren't holding a seed packet, I implemented particle fading, I implemented toggleable rain particles, along with
a rain loop that plays that I made myself. Overall, I'm pretty happy. Again, I had a great time working on it. The refactoring at the start was a bit slow and somewhat boring, but
it wasn't bad.

The last thing that I *really* need to do is make my own zombie sprite. Then the entire thing will be made by me! This project is addictive to work on. I think it's because it's
just pure code. This is what feels good to me for making certain things. It's just fun as hell to work on, and it feels like I can keep coming up with ways to improve/polish the
game, and have fun implementing those things. I really need to try to apply some of this mentality to future games I make in godot, because I developed a horrible attitude towards
that engine. I should try to implmement things simply and just enjoy the process.


24/02/2024

Today I spent 4 hours 16 minutes working on the game. A short amount of that time (around 10 minutes at most) was some work on a sprite. I got quite a lot done. Here's a list of the
things I did:

-Made it so the screen can be resized, by using a render texture.
-I implemented an immediate-mode-style button
-I added buttons for the start/quit and return to start
-I implemented a pause menu, with options for toggling rain and music
-I made and used a wood texture for the top bar.

A more detailed breakdown of the approximate time I spent working on particular things:

Spent 57 minutes just to add screen resizing, but it weirdly didn't feel like a long time.
Spent only about 25 minutes implementing an immediate-mode button.
Spent about 20 minutes or so implementing pause menu/button.
About 7 minutes implementing toggle rain/music buttons.
The rest of time I spent on smaller stuff

Overall a solid day. I decided to *start* my day with this project today, so I wouldn't have to stay up late at night working on it. Maybe this will be something I continue to do, especially
for future projects. If I could have this level of enthusiam for workin on a game in godot, I'd be able to get a lot done! Hopefully I can!

I ended up spending another hour and 13 minutes (which I *have* added to the above time, now), later on in the day, just because I felt like it. It's addictive! The extra stuff I did was fairly
small, I did a silly experiment where I rendered some memory of the particles array to a texture, which I ended up removing. I also spent a lot of time refactoring some of the button/text drawing
code, to make centering it easier. The code is starting to get a bit unweildy, though, so I may end up putting the UI and text rendering stuff in its own file.

I also ended up spending another 23 minutes..... I added it to the above time. I made it so buttons can have a minWidth to line them up nicely.

As the project starts growing, it is getting harder to work with, and this is a good thing, it means that I'm going to be challenging myself and probably actually improve. Pushing yourself
beyond your comfort zone is how you make the most improvements, so trying to clean up the areas of code that I think code be useful to clean will challenge me, and will help me become better.
I suppose the question is, how do you know when to refactor something? I think if the code is hard to work with, and semantically complex, then it is worth spending some time refactoring it,
because while you may never use that code again, you may need to read it again, and making it easier for yourself to understand as much of the project as possible is a good idea. Refactoring
will do this. But also, there's tradeoffs. Refactoring will take you time, and sometimes the amount of time it will take may not be worse the benefit, so you need to think about it a bit
before you decide to refactor/semantically compress it.


25/02/2024

Today I spent 1 hour 22 minutes. I refactored some code and seperated the UI code into its own file. I fixed the gameover screen, because the button and text weren't drawing in good
positions. I implemented a simple config file for saving the state of raining, playingMusic and fullscreen. I did plenty more refactoring, removing old code, shortening bits of code
by simplifying them etc.. Finally I added some confetti explosions when zombies are hit, that happen 1/25 times. Mostly refactoring, which is not bad. It's not to make code easier to
understand, and more concise.


26/02/2024

Today I spent 1 hour 28 minutes. I made multiple rain particles spawn per-frame because I noticed that the real pvz had so much more rain particles and I preferred the look. I also fixed a "bug"
where the rain particles were fading, which wasn't what I wanted. I made a little zombie walk animation by using sin(time) and putting a scale field on the Zombie. For this, I had to make
DrawTextureCentered take a scale, which I thought would be difficult, but I did it in like 30 seconds. Because I made that function, I realised I could refactor the plant icons on the seed
packets, which were using hardcoded values to center them, since they were scaled down, now with this updated function I could do that automatically. I finally implemented a function for
getting the center of a sprite, since I had to use that for centering the plants. Because of that, I removed SHADOW_ORIGIN, which represented the center of the shadow, since I now have a
function that will calculate it for me. I spent spent like a single minute making the zombies scale different based on their x pos, so they don't all animate at the same time. I didn't count
this time, though, since it was such a short amount.

Overall, not a massive amount done, but I wanted to keep it a bit shorter today. I also spent another 33 minutes just looking over the code and refactoring parts. I added the time to the above
time.


27/02/2024

(NOTE: I spent around 13 minutes drawing the zombie sprite, but I didn't add that to the time below.)

I spent 33 minutes today. I fixed zombies not spawning, I added some simple scale animations to the plants to make them seem more alive. I also tweaked the zombie scaling so even when they're
close to eachother, their scaling is fairly different.


28/02/2024

Today I spent 1 hour 57 minutes. I started using some designations on structs, where you specify the field you want to set, which I didn't realise was in C99. I also seperated out the options
to a config menu, and added the peashoot sound when press a button for some more feedback. I added the pop sound to confetti to make it a bit more fun. The biggest thing I did was add rolling
heads to zombies. It was great fun, and I didn't run into any trouble. I think it looks funny! Then I made the zombies to keep taking shots and walk for a bit once they're dead, to give the
zombies behind them more of a chance. Finally I fixed some issues I accidentally introduced to reading/writing config when refactoring the config into a struct.

Overall, pretty solid, I'm happy with what I got done today!


29/02/2024

(Note: I spent around 22 minutes recording sounds. This isn't added to the below time, which focuses mainly on code)

Today I spent 1 hour 18 minutes today. A tiny amount of that time (less than 5 minutes) was spent "drawing" a cursor which was scrapped when I realised I couldn't use a custom cursor nicely.
I renamed the macro and function associated with getting an object from an array, and incrementing the array index, I think it's more clear now. I made the zombie animation change based on their
speed and their array index, which helps stop them overlapping when they're at the same position. I refactored the wave-related globals into a struct. I fade out zombies when they're headless, and
I figured out a great way of fading them out only once they reach 50% time left. Basically, you get the percentage by doing Clamp(currentTime*x / maxTime, 0, 1). the variable x can scale the timer,
so if x is 2, the timer will be doubled. What this effectively does it make it so that when currentTime is at 50%, it will be doubled to 100%, so at 50% is when the actual fading will start. This
is a very helpful kind of formula that I could use for particles to, to control when they begin fading.








